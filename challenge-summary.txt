DEVOPS
The PCI Audit Breach: Rebuild FlexPay's Secrets Pipeline in 48 Hours
The Scenario
It's Tuesday morning at Yuno, and you've just been pulled into an emergency call with the Head of Compliance and the VP of Engineering. Yesterday, during a surprise PCI-DSS audit spot-check for one of Yuno's largest merchant clients (FlexPay, a cross-border remittance platform processing $4M daily), the auditors identified a critical compliance violation: payment gateway credentials were found hardcoded in environment variables of container images stored in the container registry.

The finding triggers a mandatory 48-hour remediation window. If FlexPay doesn't demonstrate compliant secrets management by Thursday, they lose their payment processing certificationâ€”and Yuno loses a flagship client generating $120K MRR.

The Platform Engineering team has 48 hours to rebuild FlexPay's payment service deployment pipeline with production-grade secrets management, and they need a working proof-of-concept infrastructure that can be reviewed by the auditors on Thursday morning. You've been assigned to build this PoC.

The current setup is a Node.js payment gateway service that connects to three different payment processors (each requiring API credentials). The service currently reads credentials from environment variables baked into Docker images during CI build time. The auditors specifically flagged: credentials in plaintext in CI logs, credentials in container layers, and no evidence of credential rotation capability.

Domain Background
Before you begin, here are the key concepts you need to understand:

Payment/Fintech Terms
Payment Gateway Service: A backend service that sits between a merchant's application and payment processors (like Stripe, Adyen, or regional acquirers). It receives payment requests, authenticates with the processor using API credentials, forwards transaction data, and returns the processor's response.

Payment Processor Credentials: Sensitive API keys, merchant IDs, and secrets that authenticate the gateway service to external payment processors. These are the most critical secrets in a payment infrastructureâ€”if compromised, attackers can initiate fraudulent transactions, access transaction data, or cause service disruption.

PCI-DSS (Payment Card Industry Data Security Standard): A set of security standards designed to ensure that all companies that accept, process, store, or transmit credit card information maintain a secure environment. Key infrastructure requirements include:

Never storing credentials in plaintext in code, configs, or container images
Implementing access controls and encryption for sensitive data
Maintaining audit logs of access to secrets
Demonstrating capability for credential rotation
Acquirer/Processor: The financial institution or payment company that processes card transactions on behalf of merchants. Examples include Stripe, PayPal, Adyen, or regional banks. Each requires unique API credentials.

Infrastructure Terms
Secrets Management: The practice of securely storing, accessing, and rotating sensitive data (passwords, API keys, certificates) needed by applications. Production systems use dedicated secrets managers (AWS Secrets Manager, HashiCorp Vault, GCP Secret Manager) rather than environment variables or config files.

Secrets Rotation: The process of periodically changing credentials to limit the window of exposure if a secret is compromised. Compliant systems must demonstrate that rotating a credential doesn't require redeploying services or cause downtime.

Immutable Infrastructure: Infrastructure pattern where servers/containers are never modified after deploymentâ€”new versions are deployed as entirely new instances. This means credentials can't be baked into images; they must be injected at runtime.

CI/CD Pipeline: Continuous Integration/Continuous Deployment pipelineâ€”the automated process that builds, tests, and deploys code. PCI-DSS requires that CI logs don't expose secrets, and that secrets are only available to the runtime environment, not the build environment.

Zero-Downtime Deployment: A deployment strategy that updates a service without interrupting traffic. Common patterns include rolling updates (gradually replace instances) or blue-green deployment (run two environments, switch traffic). For payment services, even 30 seconds of downtime can mean lost transactions.

Health Checks: Endpoints or probes that container orchestrators use to determine if a service instance is healthy and ready to receive traffic. Critical for zero-downtime deploysâ€”unhealthy instances are removed from the load balancer.

Your Mission
Build a proof-of-concept infrastructure that demonstrates PCI-DSS compliant secrets management for FlexPay's payment gateway service. Your solution must show the auditors (and Yuno's compliance team) that:

Payment processor credentials are never exposed in container images, CI logs, or code repositories
The service can retrieve credentials securely at runtime from a secrets management system
The deployment pipeline supports zero-downtime deployments so credential rotation won't disrupt transaction processing
Core Requirements
Requirement 1: Secrets Management Infrastructure Implement a secrets management solution where the payment gateway service retrieves processor credentials at runtime (not at build time). The solution must demonstrate:

Storage of at least 3 different payment processor credentials (you can use mock credentials like PROCESSOR_A_API_KEY, PROCESSOR_B_MERCHANT_ID, etc.)
A secure method for the containerized service to authenticate to the secrets manager and retrieve credentials
Clear separation: CI/CD pipeline does NOT have access to production secrets; only the runtime environment does
Requirement 2: Compliant CI/CD Pipeline Create a CI/CD pipeline that builds and deploys the payment service WITHOUT exposing secrets in logs or artifacts. The pipeline should:

Build a Docker image with NO hardcoded credentials (prove this by documenting how you validated the image)
Deploy the service to a container orchestration environment (local Docker Compose, Minikube, or cloud K8s)
Include at least one security gate (e.g., image scanning, secret detection in code, vulnerability check)
Requirement 3: Zero-Downtime Deployment Capability Configure the deployment to support rolling updates without dropping payment transactions. Your solution should demonstrate:

Health checks that prevent traffic from reaching instances before they've loaded credentials
A deployment strategy that maintains at least one healthy instance during updates
Documentation of how credential rotation would work without redeploying containers (this can be theoretical if you don't implement hot-reload, but must be clearly explained)
Stretch Goals (Partial Completion Expected)
These are NOT required for a strong submission. Complete only if time permits:

Secrets Rotation Automation: Implement a mechanism (script, operator, cron job) that simulates rotating a credential in the secrets manager and demonstrates how running containers would detect and reload the new value
Audit Logging: Add logging that records when secrets are accessed, by which service instance, and at what timeâ€”exportable in a format an auditor could review
Multi-Environment Secrets Isolation: Extend your solution to show how development, staging, and production environments would have completely isolated secrets with different access policies
Note: Prioritize completing the 3 core requirements with high quality over attempting stretch goals. The auditors care most about demonstrating the fundamentals correctly.

Constraints and Guidance
Time: This is a 2-hour challenge. Focus on demonstrating the concepts clearly rather than production-level polish. A well-documented, working local setup is better than an incomplete cloud deployment.

Environment: You may build this for any environment you're comfortable withâ€”local Docker Compose, Minikube, AWS, GCP, Azure. Choose based on what you can deliver confidently in 2 hours. Clearly document setup instructions.

Service Code: You DON'T need to write a full payment gateway. A minimal Node.js/Python/Go HTTP service that reads secrets on startup and exposes a health check endpoint is sufficient. The infrastructure is what's being evaluated, not the application code.

Deliberate Ambiguity: The requirements intentionally don't specify which secrets manager to use, which orchestration platform, or which deployment strategy. Your choice and justification are part of the assessment.

Required Deliverables
Submit a Git repository containing:

Infrastructure as Code: Terraform/Pulumi/CloudFormation modules OR Docker Compose / Kubernetes manifests that provision the secrets management infrastructure and deploy the payment service

CI/CD Pipeline Definition: A GitHub Actions, GitLab CI, or equivalent pipeline file that demonstrates compliant build and deployment

Service Code: Minimal payment gateway service code that retrieves secrets from your secrets manager and exposes a health endpoint

Design Decisions Document (CRITICAL): A markdown document (500-1000 words) that explains:

Why you chose your specific secrets management approach and what alternatives you considered
How your solution satisfies each of the 3 core requirements
What security trade-offs exist in your 2-hour PoC vs. what you'd implement in production
How credential rotation would work in your design (step-by-step)
What failure scenarios exist and how your design handles them (e.g., secrets manager unavailable, credential expired, unhealthy instance)
Setup and Validation Instructions: Clear README with commands to run your infrastructure, verify secrets are NOT in container images, trigger a deployment, and test health checks

What the Auditors (Evaluators) Will Check
Can they follow your README and get the infrastructure running?
Can they inspect the container image and confirm NO credentials are present?
Can they read your CI/CD logs and confirm NO credentials are exposed?
Does your Design Decisions doc demonstrate understanding of PCI-DSS secrets management principles?
Does the deployment strategy plausibly support zero-downtime updates?
Good luck. FlexPay's certification depends on you. ðŸš€

Deliverables
-
Infrastructure as Code (Terraform/Pulumi/CloudFormation) OR container orchestration configs (Docker Compose/Kubernetes manifests) that provision secrets management infrastructure and deploy the payment service
-
CI/CD pipeline definition (GitHub Actions, GitLab CI, or equivalent) demonstrating compliant build and deployment with security gates
-
Minimal payment gateway service code (Node.js/Python/Go) that retrieves secrets at runtime and exposes health check endpoint
-
Design Decisions document (500-1000 words markdown) explaining tool choices, requirement satisfaction, security trade-offs, credential rotation workflow, and failure scenario handling
-
Setup and validation instructions (README) with commands to deploy infrastructure, verify no credentials in images, trigger deployment, and test health checks
Evaluation Criteria
Secrets Management Implementation (25 points): Quality of secrets storage and runtime retrieval solution. Bottom quartile (0-10): Credentials still in environment variables or config files; no real secrets manager used. Median (13-18): Working secrets manager (Vault, AWS Secrets Manager, etc.) with runtime retrieval, but service has overly broad access or authentication is insecure. Top quartile (20-25): Production-grade secrets manager with least-privilege access policies, secure service authentication (IAM roles, service accounts), clear separation of build-time vs runtime access.
25pts
CI/CD Pipeline Security & Compliance (20 points): How well the pipeline prevents credential exposure and includes security gates. Bottom quartile (0-8): Secrets visible in logs or build artifacts; no security scanning. Median (10-14): Pipeline avoids exposing secrets but lacks security gates or has minor log leakage risks. Top quartile (16-20): Clean logs with masked secrets, security scanning integrated (image scan, secret detection), clear evidence that production secrets are never available to CI environment.
20pts
Zero-Downtime Deployment Design (20 points): Quality of health checks and deployment strategy. Bottom quartile (0-8): No health checks or deployment strategy that clearly causes downtime. Median (10-14): Basic health checks present but deployment strategy is naive (e.g., stops all instances then starts new ones); or unclear if secrets are loaded before health passes. Top quartile (16-20): Proper rolling update with health/readiness checks that verify secrets are loaded; clear documentation of traffic management during updates; deployment config maintains availability.
20pts
Design Decisions & Technical Communication (25 points): Depth and clarity of the written design document. Bottom quartile (0-10): Superficial explanations or missing document; doesn't address trade-offs or failure scenarios. Median (13-18): Solid explanations of tool choices and how requirements are met, but lacks depth on trade-offs or production differences; minimal failure scenario analysis. Top quartile (20-25): Thoughtful analysis of alternatives; clear articulation of PoC vs production trade-offs; detailed credential rotation workflow; comprehensive failure scenario handling; demonstrates deep understanding vs copy-paste.
25pts
Code Quality, Documentation & Reproducibility (10 points): Organization, documentation, and whether evaluators can actually run it. Bottom quartile (0-4): Disorganized repo, missing or incorrect setup instructions, can't verify the solution works. Median (5-7): Clear structure, mostly working instructions, minor setup issues or missing validation steps. Top quartile (8-10): Professional repo structure, comprehensive README with validation commands, easy to run and verify; includes commands to inspect image for credentials.
10pts
Total
100pts